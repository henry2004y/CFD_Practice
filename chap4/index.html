<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/CFD_Practice/libs/highlight/github.min.css"> <link rel=stylesheet  href="/CFD_Practice/css/franklin.css"> <link rel=stylesheet  href="/CFD_Practice/css/pure.css"> <link rel=stylesheet  href="/CFD_Practice/css/side-menu.css"> <style> .franklin-content{padding-left:10%;} @media (min-width: 940px) { .franklin-content {width: 640px; margin-left: 0px; padding-left: 80px;} .header {width: 700px;} } </style> <link rel=icon  href="/CFD_Practice/assets/favicon.png"> <title>The Discontinuous Galerkin Method</title> <div id=layout > <a href="#menu" id=menuLink  class=menu-link ><span></span></a> <div id=menu > <div class=pure-menu > <a class=pure-menu-heading  href="#">Pure-SM</a> <ul class=pure-menu-list > <li class="pure-menu-item "><a href="/CFD_Practice/" class=pure-menu-link >Home</a> <li class="pure-menu-item "><a href="/CFD_Practice/chap1/" class=pure-menu-link >Math</a> <li class="pure-menu-item "><a href="/CFD_Practice/chap2/" class=pure-menu-link >Mesh Generation</a> <li class="pure-menu-item pure-menu-selected"><a href="/CFD_Practice/chap4/" class=pure-menu-link >DG</a> <li class="pure-menu-item pure-menu-selected"><a href="/CFD_Practice/Incompressible/" class=pure-menu-link >Incompressible</a> </ul> </div> </div> <div id=main > <div class=header > <h1>The Discontinuous Galerkin Method</h1> <h2>Not just notes</h2> </div> <div class=franklin-content ><div class=franklin-toc ><ol><li><a href="#1d_scalar_conservation">1D Scalar Conservation</a><li><a href="#1d_advection-diffusion">1D Advection-Diffusion</a></ol></div> <h1 id=one-dimensional_conservation_laws ><a href="#one-dimensional_conservation_laws" class=header-anchor >One-Dimensional Conservation Laws</a></h1> <h2 id=1d_scalar_conservation ><a href="#1d_scalar_conservation" class=header-anchor >1D Scalar Conservation</a></h2> <p>The full Julia implementation can be found at ... Note that when p ≥ 4, the scheme becomes unstable. I wonder what&#39;s the reason behind.</p> <h2 id=1d_advection-diffusion ><a href="#1d_advection-diffusion" class=header-anchor >1D Advection-Diffusion</a></h2> <h1 id=libraries ><a href="#libraries" class=header-anchor >Libraries</a></h1> <p><a href="https://github.com/JuliaAlgebra/MultivariatePolynomials.jl">MultivariatePolynomials.jl</a>: package for constructing Legendre basis functions. It is not very user-friendly.</p> <p><a href="https://github.com/JuliaFEM/FEMQuad.jl">FEMQuad.jl</a>: numerical integration schemes for cartesian and tetrahedron domains. I use it for obtaining Gauss-Legendre integral points in triangles, i.e. Dunavant points.</p> <h1 id=code_optimizations ><a href="#code_optimizations" class=header-anchor >Code Optimizations</a></h1> <p>Even if some programming languages have libraries for polynomials and basis, it is generally not good to evaluate polynomials everytime when you do computations within the time steps. Remember the extremely slow version of 1D shallow-water DG solver implemented with symbolic functions in MATLAB? I tend to write that way the first time because it has a very similar form to the mathematical expression, but in practice, I should not do that.</p> <p>For example, let the coefficients be stored in an array named <code>coef_PVE</code>. To get the density at a point location with basis function <code>ϕ</code> in reference space <code>&#40;ξ, η&#41;</code>,</p> <pre><code class=language-julia >ρ &#61; sum&#40;coef_PVE&#91;:,ρ_,  k&#93; .* ϕ&#41;&#40;ξ&#61;&gt;x&#91;1&#93;, η&#61;&gt;x&#91;2&#93;&#41;</code></pre>
<p>Alternatively, we can precompute the basis function values at quadrature points and store them as float arrays. Since the unknowns of FEM are multiplier coefficients of basis functions, we can have highly efficient computations of getting physical quantities and evaluating integrals through simple floating point arithmatics:</p>
<pre><code class=language-julia >ρ &#61; sum&#40;coef_PVE&#91;:,ρ_,   k&#93; .* phi&#91;:,j&#93;&#41;</code></pre>
<p>where <code>phi</code> is the precomputed values of basis functions evaluated at quadrature points.</p>
<p>However, since the solutions of finite element methods are functions, in principle we can obtain values at any given location in our simulation domain. When doing visualizations, it may be better to evaluate our solution at more points than the quadrature points used for computation. In this case, we can switch back to the polynomial evaluations. </p>
<div class=page-foot >
  <div class=copyright >
    &copy; Hongyang Zhou. Last modified: June 22, 2021. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a>.
  </div>
</div>
</div>
      </div> 
  </div> 
  <script src="/CFD_Practice/libs/pure/ui.min.js"></script>
  
  
      <script src="/CFD_Practice/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>